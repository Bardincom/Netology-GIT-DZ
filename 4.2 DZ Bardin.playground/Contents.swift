import UIKit

//MARK: Homework for lesson 4.2

//MARK: Задача №1
/// История:
///Вы разрабатываете спутник для полета на Европу (спутник Юпитера). В вашей команде два ученых по космодинамике. Вы даете каждому из них задачу расчитать количество топлива для достижения спутником цели.
///Данные, которые они получают — это вес спутника и длина полета. Они должны вам предоставить свои алгоритмы расчетов топлива (это ваши Замыкания). А вы по готовности алгоритмов делаете обработку данных и сравниваете результат (это ваша Функция).
///Алгоритм выполнения
///Написать функцию с входящим параметром — Замыкание (тип указан выше). Функция должна выводить в консоль результат выполнения Замыкания.
///Написать два Замыкания (тип указан выше). Внутри должна быть математическая операция (на ваш выбор) над входящими значениями.
///Вызвать функцию для первого Замыкания и потом для второго Замыкания.
///Выполнить задание, не сокращая синтаксис языка.
///Тип для Замыкания: на входе два параметра Double, На Выходе Double.


//создаю функция входящие значения которой будут вес спутника и расстояние полета - эти данные будут использоваться в следующем входящем параметре замыкания для расчета который будут передавать ученые.
func dataProcessing (weight: Double, distance: Double, calculation fuel: (Double, Double) -> Double) {
  print("Результат расчета сделанный ученым: \(fuel(weight, distance))\n")
}

// алгоритмы расчетов ученых, поступают два параметра типа Double, замыкание должно вернуть результат в Double
let resaultSheldon = { (weight: Double, distance: Double) -> Double in
  return (weight + distance) * 3.14 // вымышленная формула
}

let resaultVolovetc = { (weight: Double, distance: Double) -> Double in
  return ((distance * 100 * 3.14) / weight)
}

// вызываю функцию используя полученные варианты расчета ученых
dataProcessing(weight: 14, distance: 24000, calculation: resaultSheldon)
dataProcessing(weight: 14, distance: 24000, calculation: resaultVolovetc)


//MARK: Задача №2
///В вашем конструкторском бюро случилось ЧП и все компьютеры вышли из строя, но последние алгоритмы вы помните. Вы намерены добраться до ближайшего компьютера в соседнем селе и восстановить из своей памяти нужные данные. Ваша задача запомнить максимально краткую форму записи алгоритмов, чтобы все не смешалось в голове.
///Алгоритм выполнения
///Представить задание 1 в сокращенном виде.

// алгоритмы в сокращенном виде
let algorithmSheldonRecovery: (Double, Double) -> Double = {($0 + $1) * 3.14}
let algorithmVolovetcRecovery: (Double, Double) -> Double = {($1 * 100 * 3.14) / $0}

// еще можно создать typealias, в который мы передали тип замыкания, это позволило нам еще больше сократить наш код
typealias ClouserType = (Double, Double) -> Double
let algorithmPenny: ClouserType = {($0 + $1)}


// вызываю функцию
dataProcessing(weight: 14, distance: 24000, calculation: algorithmSheldonRecovery)
dataProcessing(weight: 14, distance: 24000, calculation: algorithmVolovetcRecovery)
dataProcessing(weight: 14, distance: 24000, calculation: algorithmPenny)


//MARK: Задача 3(*)
///Пока вы добирались до села с компьютером, вам пришла в голову мысль своего алгоритма. Вы решили использовать свою функцию для проверки гипотезы и стали набирать алгоритм прямо в ней (реализация Замыкания вместо параметра).
///Алгоритм выполнения
///Вызвать функцию из задания 1, определив ей Замыкание самостоятельно (не передавая).
///Объяснить, куда и почему исчезло ключевое слово ('param' - в примере) для параметра.

dataProcessing(weight: 14, distance: 24000) {($0 + $1) * 2.771}
/// calculation - это по сути константа и ей присвоена функция которая должна вернуть тип Double, разворачивая ее клавишей Return на клавиатуре мы открываем тело функции {...} в которой и происходит нужное действие, в нашем случае некая математическая операция. В своем примере я записал в сокрщенном синтаксисе реализацию данного замыкания, хотя можно рассписать ее в полном виде как было сделано в задаче №1
